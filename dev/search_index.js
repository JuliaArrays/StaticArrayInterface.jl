var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Traits","page":"API","title":"Traits","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"StaticArrayInterface.contiguous_axis\nStaticArrayInterface.contiguous_axis_indicator\nStaticArrayInterface.contiguous_batch_size\nStaticArrayInterface.dimnames\nStaticArrayInterface.has_dimnames\nStaticArrayInterface.has_parent\nStaticArrayInterface.is_column_major\nStaticArrayInterface.is_lazy_conjugate\nStaticArrayInterface.is_splat_index\nStaticArrayInterface.known_dimnames\nStaticArrayInterface.known_first\nStaticArrayInterface.known_last\nStaticArrayInterface.known_length\nStaticArrayInterface.known_offset1\nStaticArrayInterface.known_offsets\nStaticArrayInterface.known_size\nStaticArrayInterface.known_step\nStaticArrayInterface.known_strides","category":"page"},{"location":"api/#StaticArrayInterface.contiguous_axis","page":"API","title":"StaticArrayInterface.contiguous_axis","text":"contiguous_axis(::Type{T}) -> StaticInt{N}\n\nReturns the axis of an array of type T containing contiguous data. If no axis is contiguous, it returns a StaticInt{-1}. If unknown, it returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticArrayInterface.contiguous_axis_indicator","page":"API","title":"StaticArrayInterface.contiguous_axis_indicator","text":"contiguous_axis_indicator(::Type{T}) -> Tuple{Vararg{StaticBool}}\n\nReturns a tuple boolean Vals indicating whether that axis is contiguous.\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticArrayInterface.contiguous_batch_size","page":"API","title":"StaticArrayInterface.contiguous_batch_size","text":"contiguous_batch_size(::Type{T}) -> StaticInt{N}\n\nReturns the Base.size of contiguous batches if !isone(stride_rank(T, contiguous_axis(T))). If isone(stride_rank(T, contiguous_axis(T))), then it will return StaticInt{0}(). If contiguous_axis(T) == -1, it will return StaticInt{-1}(). If unknown, it will return nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticArrayInterface.dimnames","page":"API","title":"StaticArrayInterface.dimnames","text":"dimnames(x) -> Tuple{Vararg{Union{Symbol,StaticSymbol}}}\ndimnames(x, dim::Union{Int,StaticInt}) -> Union{Symbol,StaticSymbol}\n\nReturn the names of the dimensions for x. :_ is used to indicate a dimension does not have a name.\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticArrayInterface.has_dimnames","page":"API","title":"StaticArrayInterface.has_dimnames","text":"has_dimnames(::Type{T}) -> Bool\n\nReturns true if x has on or more named dimensions. If all dimensions correspond to :_, then false is returned.\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticArrayInterface.has_parent","page":"API","title":"StaticArrayInterface.has_parent","text":"has_parent(::Type{T}) -> StaticBool\n\nReturns static(true) if parent_type(T) a type unique to T.\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticArrayInterface.is_column_major","page":"API","title":"StaticArrayInterface.is_column_major","text":"is_column_major(A) -> StaticBool\n\nReturns True() if elements of A are stored in column major order. Otherwise returns False().\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticArrayInterface.is_lazy_conjugate","page":"API","title":"StaticArrayInterface.is_lazy_conjugate","text":"is_lazy_conjugate(::AbstractArray) -> Bool\n\nDetermine if a given array will lazyily take complex conjugates, such as with Adjoint. This will work with nested wrappers, so long as there is no type in the chain of wrappers such that parent_type(T) == T\n\nExamples\n\njulia> a = transpose([1 + im, 1-im]')\n2×1 transpose(adjoint(::Vector{Complex{Int64}})) with eltype Complex{Int64}:\n 1 - 1im\n 1 + 1im\n\njulia> is_lazy_conjugate(a)\nTrue()\n\njulia> b = a'\n1×2 adjoint(transpose(adjoint(::Vector{Complex{Int64}}))) with eltype Complex{Int64}:\n 1+1im  1-1im\n\njulia> is_lazy_conjugate(b)\nFalse()\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticArrayInterface.is_splat_index","page":"API","title":"StaticArrayInterface.is_splat_index","text":"is_splat_index(::Type{T}) -> Bool\n\nReturns static(true) if T is a type that splats across multiple dimensions.\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticArrayInterface.known_dimnames","page":"API","title":"StaticArrayInterface.known_dimnames","text":"known_dimnames(::Type{T}) -> Tuple{Vararg{Union{Symbol,Nothing}}}\nknown_dimnames(::Type{T}, dim::Union{Int,StaticInt}) -> Union{Symbol,Nothing}\n\nReturn the names of the dimensions for x. :_ is used to indicate a dimension does not have a name.\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticArrayInterface.known_first","page":"API","title":"StaticArrayInterface.known_first","text":"known_first(::Type{T}) -> Union{Int,Nothing}\n\nIf first of an instance of type T is known at compile time, return it. Otherwise, return nothing.\n\njulia> known_first(typeof(1:4))\nnothing\n\njulia> known_first(typeof(Base.OneTo(4)))\n1\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticArrayInterface.known_last","page":"API","title":"StaticArrayInterface.known_last","text":"known_last(::Type{T}) -> Union{Int,Nothing}\n\nIf last of an instance of type T is known at compile time, return it. Otherwise, return nothing.\n\njulia> known_last(typeof(1:4))\nnothing\n\njulia> known_first(typeof(static(1):static(4)))\n4\n\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticArrayInterface.known_length","page":"API","title":"StaticArrayInterface.known_length","text":"known_length(::Type{T}) -> Union{Int,Nothing}\n\nIf length of an instance of type T is known at compile time, return it. Otherwise, return nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticArrayInterface.known_offset1","page":"API","title":"StaticArrayInterface.known_offset1","text":"known_offset1(::Type{T}) -> Union{Int,Nothing}\n\nReturns the linear offset of array x if known at compile time.\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticArrayInterface.known_offsets","page":"API","title":"StaticArrayInterface.known_offsets","text":"known_offsets(::Type{T}) -> Tuple\nknown_offsets(::Type{T}, dim) -> Union{Int,Nothing}\n\nReturns a tuple of offset values known at compile time. If the offset of a given axis is not known at compile time nothing is returned its position.\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticArrayInterface.known_size","page":"API","title":"StaticArrayInterface.known_size","text":"known_size(::Type{T}) -> Tuple\nknown_size(::Type{T}, dim) -> Union{Int,Nothing}\n\nReturns the size of each dimension of A or along dimension dim of A that is known at compile time. If a dimension does not have a known size along a dimension then nothing is returned in its position.\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticArrayInterface.known_step","page":"API","title":"StaticArrayInterface.known_step","text":"known_step(::Type{T}) -> Union{Int,Nothing}\n\nIf step of an instance of type T is known at compile time, return it. Otherwise, return nothing.\n\njulia> known_step(typeof(1:2:8))\nnothing\n\njulia> known_step(typeof(1:4))\n1\n\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticArrayInterface.known_strides","page":"API","title":"StaticArrayInterface.known_strides","text":"known_strides(::Type{T}) -> Tuple\nknown_strides(::Type{T}, dim) -> Union{Int,Nothing}\n\nReturns the strides of array A known at compile time. Any strides that are not known at compile time are represented by nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#Functions","page":"API","title":"Functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"StaticArrayInterface.static_axes\nStaticArrayInterface.axes_types\nStaticArrayInterface.broadcast_axis\nStaticArrayInterface.deleteat\nStaticArrayInterface.dense_dims\nStaticArrayInterface.from_parent_dims\nStaticArrayInterface.getindex\nStaticArrayInterface.indices\nStaticArrayInterface.insert\nStaticArrayInterface.static_length\nStaticArrayInterface.lazy_axes\nStaticArrayInterface.offset1\nStaticArrayInterface.offsets\nStaticArrayInterface.setindex!\nStaticArrayInterface.static_size\nStaticArrayInterface.static_strides\nStaticArrayInterface.to_axes\nStaticArrayInterface.to_axis\nStaticArrayInterface.to_dims\nStaticArrayInterface.to_index\nStaticArrayInterface.static_to_indices\nStaticArrayInterface.to_parent_dims\nStaticArrayInterface.unsafe_reconstruct","category":"page"},{"location":"api/#StaticArrayInterface.static_axes","page":"API","title":"StaticArrayInterface.static_axes","text":"static_axes(A) -> Tuple{Vararg{AbstractUnitRange{Int}}}\nstatic_axes(A, dim) -> AbstractUnitRange{Int}\n\nReturns the axis associated with each dimension of A or dimension dim. static_axes(::AbstractArray) behaves nearly identical to Base.axes with the exception of a handful of types replace Base.OneTo{Int} with SOneTo. For example, the axis along the first dimension of Transpose{T,<:AbstractVector{T}} and Adjoint{T,<:AbstractVector{T}} can be represented by SOneTo(1). Similarly, Base.ReinterpretArray's first axis may be statically sized.\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticArrayInterface.axes_types","page":"API","title":"StaticArrayInterface.axes_types","text":"axes_types(::Type{T}) -> Type{Tuple{Vararg{AbstractUnitRange{Int}}}}\naxes_types(::Type{T}, dim) -> Type{AbstractUnitRange{Int}}\n\nReturns the type of each axis for the T, or the type of of the axis along dimension dim.\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticArrayInterface.broadcast_axis","page":"API","title":"StaticArrayInterface.broadcast_axis","text":"broadcast_axis(x, y)\n\nBroadcast axis x and y into a common space. The resulting axis should be equal in length to both x and y unless one has a length of 1, in which case the longest axis will be equal to the output.\n\njulia> broadcast_axis(1:10, 1:10)\n\njulia> broadcast_axis(1:10, 1)\n1:10\n\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticArrayInterface.deleteat","page":"API","title":"StaticArrayInterface.deleteat","text":"deleteat(collection, index)\n\nReturns a new instance of collection with the item at the given index removed.\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticArrayInterface.dense_dims","page":"API","title":"StaticArrayInterface.dense_dims","text":"dense_dims(::Type{<:AbstractArray{N}}) -> Tuple{Vararg{StaticBool,N}}\n\nReturns a tuple of indicators for whether each axis is dense. An axis i of array A is dense if stride(A, i) * Base.size(A, i) == stride(A, j) where stride_rank(A)[i] + 1 == stride_rank(A)[j].\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticArrayInterface.from_parent_dims","page":"API","title":"StaticArrayInterface.from_parent_dims","text":"from_parent_dims(::Type{T}) -> Tuple{Vararg{Union{StaticInt,Tuple{Vararg{StaticInt}}}}}\n\nReturns the mapping from parent dimensions to child dimensions.\n\n!!! Warning     This method is still experimental and may change without notice.\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticArrayInterface.indices","page":"API","title":"StaticArrayInterface.indices","text":"indices(x, dim) -> AbstractUnitRange{Int}\n\nGiven an array x, this returns the indices along dimension dim.\n\n\n\n\n\nindices(x) -> AbstractUnitRange{Int}\n\nReturns valid indices for the entire length of x.\n\n\n\n\n\nindices(x::Tuple) -> AbstractUnitRange{Int}\n\nReturns valid indices for the entire length of each array in x.\n\n\n\n\n\nindices(x::Tuple, dim)  -> AbstractUnitRange{Int}\n\nReturns valid indices for each array in x along dimension dim\n\n\n\n\n\nindices(x::Tuple, dim::Tuple) -> AbstractUnitRange{Int}\n\nReturns valid indices given a tuple of arrays x and tuple of dimesions for each respective array (dim).\n\n\n\n\n\nindices(x, dim::Tuple) -> Tuple{Vararg{AbstractUnitRange{Int}}}\n\nReturns valid indices for array x along each dimension specified in dim.\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticArrayInterface.insert","page":"API","title":"StaticArrayInterface.insert","text":"insert(collection, index, item)\n\nReturns a new instance of collection with item inserted into at the given index.\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticArrayInterface.static_length","page":"API","title":"StaticArrayInterface.static_length","text":"static_length(A) -> Union{Int,StaticInt}\n\nReturns the length of A.  If the length is known at compile time, it is returned as Static number.  Otherwise, static_length(A) is identical to Base.length(A).\n\njulia> using StaticArrays, ArrayInterface\n\njulia> A = @SMatrix rand(3,4);\n\njulia> static_length(A)\nstatic(12)\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticArrayInterface.lazy_axes","page":"API","title":"StaticArrayInterface.lazy_axes","text":"lazy_axes(x)\n\nProduces a tuple of axes where each axis is constructed lazily. If an axis of x is already constructed or it is simply retrieved.\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticArrayInterface.offset1","page":"API","title":"StaticArrayInterface.offset1","text":"offset1(x) -> Union{Int,StaticInt}\n\nReturns the offset of the linear indices for x.\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticArrayInterface.offsets","page":"API","title":"StaticArrayInterface.offsets","text":"offsets(A) -> Tuple\noffsets(A, dim) -> Union{Int,StaticInt}\n\nReturns offsets of indices with respect to 0. If values are known at compile time, it should return them as Static numbers. For example, if A isa Base.Matrix, offsets(A) === (StaticInt(1), StaticInt(1)).\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticArrayInterface.setindex!","page":"API","title":"StaticArrayInterface.setindex!","text":"setindex!(A, args...)\n\nStore the given values at the given key or index within a collection.\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticArrayInterface.static_size","page":"API","title":"StaticArrayInterface.static_size","text":"static_size(A) -> Tuple\nstatic_size(A, dim) -> Union{Int,StaticInt}\n\nReturns the size of each dimension of A or along dimension dim of A. If the size of any axes are known at compile time, these should be returned as Static numbers. Otherwise, static_size(A) is identical to Base.size(A)\n\njulia> using StaticArrays, ArrayInterface\n\njulia> A = @SMatrix rand(3,4);\n\njulia> static_size(A)\n(static(3), static(4))\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticArrayInterface.static_strides","page":"API","title":"StaticArrayInterface.static_strides","text":"static_strides(A) -> Tuple{Vararg{Union{Int,StaticInt}}}\nstatic_strides(A, dim) -> Union{Int,StaticInt}\n\nReturns the strides of array A. If any strides are known at compile time, these should be returned as Static numbers. For example:\n\njulia> A = rand(3,4);\n\njulia> static_strides(A)\n(static(1), 3)\n\nAdditionally, the behavior differs from Base.strides for adjoint vectors:\n\njulia> x = rand(5);\n\njulia> static_strides(x')\n(static(1), static(1))\n\nThis is to support the pattern of using just the first stride for linear indexing, x[i], while still producing correct behavior when using valid cartesian indices, such as x[1,i]. ```\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticArrayInterface.to_axes","page":"API","title":"StaticArrayInterface.to_axes","text":"to_axes(A, inds) -> Tuple\n\nConstruct new axes given the corresponding inds constructed after to_indices(A, args) -> inds. This method iterates through each pair of axes and indices calling to_axis.\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticArrayInterface.to_axis","page":"API","title":"StaticArrayInterface.to_axis","text":"to_axis(old_axis, index) -> new_axis\n\nConstruct an new_axis for a newly constructed array that corresponds to the previously executed to_index(old_axis, arg) -> index. to_axis assumes that index has already been confirmed to be in bounds. The underlying indices of new_axis begins at one and extends the length of index (i.e., one-based indexing).\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticArrayInterface.to_dims","page":"API","title":"StaticArrayInterface.to_dims","text":"to_dims(x, dim) -> Union{Int,StaticInt}\n\nThis returns the dimension(s) of x corresponding to dim.\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticArrayInterface.to_index","page":"API","title":"StaticArrayInterface.to_index","text":"to_index([::IndexStyle, ]axis, arg) -> index\n\nConvert the argument arg that was originally passed to static_getindex for the dimension corresponding to axis into a form for native indexing (Int, Vector{Int}, etc.).\n\nto_index supports passing a function as an index. This function-index is transformed into a proper index.\n\njulia> using ArrayInterface, Static\n\njulia> to_index(static(1):static(10), 5)\n5\n\njulia> to_index(static(1):static(10), <(5))\nstatic(1):4\n\njulia> to_index(static(1):static(10), <=(5))\nstatic(1):5\n\njulia> to_index(static(1):static(10), >(5))\n6:static(10)\n\njulia> to_index(static(1):static(10), >=(5))\n5:static(10)\n\n\nUse of a function-index helps ensure that indices are inbounds\n\njulia> to_index(static(1):static(10), <(12))\nstatic(1):10\n\njulia> to_index(static(1):static(10), >(-1))\n1:static(10)\n\nNew axis types with unique behavior should use an IndexStyle trait:\n\nto_index(axis::MyAxisType, arg) = to_index(IndexStyle(axis), axis, arg)\nto_index(::MyIndexStyle, axis, arg) = ...\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticArrayInterface.static_to_indices","page":"API","title":"StaticArrayInterface.static_to_indices","text":"static_to_indices(A, I::Tuple) -> Tuple\n\nConverts the tuple of indexing arguments, I, into an appropriate form for indexing into A. Typically, each index should be an Int, StaticInt, a collection with values of Int, or a collection with values of CartesianIndex This is accomplished in three steps after the initial call to static_to_indices:\n\nExtended help\n\nThis implementation differs from that of Base.to_indices in the following ways:\n\nstatic_to_indices(A, I) never results in recursive processing of I through static_to_indices(A, static_axes(A), I). This is avoided through the use of an internal @generated method that aligns calls of static_to_indices and to_index based on the return values of ndims_index. This is beneficial because the compiler currently does not optimize away the increased time spent recursing through   each additional argument that needs converting. For example:   ```julia   julia> x = rand(4,4,4,4,4,4,4,4,4,4);\njulia> inds1 = (1, 2, 1, 2, 1, 2, 1, 2, 1, 2);\njulia> inds2 = (1, CartesianIndex(1, 2), 1, CartesianIndex(1, 2), 1, CartesianIndex(1, 2), 1);\njulia> inds3 = (fill(true, 4, 4), 2, fill(true, 4, 4), 2, 1, fill(true, 4, 4), 1);\njulia> @btime Base.to_indices(x, inds2)   1.105 μs (12 allocations: 672 bytes)   (1, 1, 2, 1, 1, 2, 1, 1, 2, 1)\njulia> @btime statictoindices(x, inds2)   0.041 ns (0 allocations: 0 bytes)   (1, 1, 2, 1, 1, 2, 1, 1, 2, 1)\njulia> @btime Base.to_indices(x, inds3);   340.629 ns (14 allocations: 768 bytes)\njulia> @btime statictoindices(x, inds3);   11.614 ns (0 allocations: 0 bytes)\n```\nRecursing through static_to_indices(A, axes, I::Tuple{I1,Vararg{Any}}) is intended to provide context for processing I1. However, this doesn't tell use how many dimensions are consumed by what is in Vararg{Any}. Using ndims_index to directly align the axes of A with each value in I ensures that a CartesiaIndex{3} at the tail of I isn't incorrectly assumed to only consume one dimension.\nBase.to_indices may fail to infer the returned type. This is the case for inds2 and inds3 in the first bullet on Julia 1.6.4.\nSpecializing by dispatch through method definitions like this: static_to_indices(::ArrayType, ::Tuple{AxisType,Vararg{Any}}, ::Tuple{::IndexType,Vararg{Any}}) require an excessive number of hand written methods to avoid ambiguities. Furthermore, if AxisType is wrapping another axis that should have unique behavior, then unique parametric types need to also be explicitly defined.\nto_index(static_axes(A, dim), index) is called, as opposed to Base.to_index(A, index). The IndexStyle of the resulting axis is used to allow indirect dispatch on nested axis types within to_index.\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticArrayInterface.to_parent_dims","page":"API","title":"StaticArrayInterface.to_parent_dims","text":"to_parent_dims(::Type{T}) -> Tuple{Vararg{Union{StaticInt,Tuple{Vararg{StaticInt}}}}}\n\nReturns the mapping from child dimensions to parent dimensions.\n\n!!! Warning     This method is still experimental and may change without notice.\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticArrayInterface.unsafe_reconstruct","page":"API","title":"StaticArrayInterface.unsafe_reconstruct","text":"unsafe_reconstruct(A, data; kwargs...)\n\nReconstruct A given the values in data. New methods using unsafe_reconstruct should only dispatch on A.\n\n\n\n\n\n","category":"function"},{"location":"api/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"StaticArrayInterface.BroadcastAxis\nStaticArrayInterface.LazyAxis\nStaticArrayInterface.OptionallyStaticStepRange\nStaticArrayInterface.OptionallyStaticUnitRange\nStaticArrayInterface.SOneTo\nStaticArrayInterface.SUnitRange\nStaticArrayInterface.StrideIndex","category":"page"},{"location":"api/#StaticArrayInterface.BroadcastAxis","page":"API","title":"StaticArrayInterface.BroadcastAxis","text":"BroadcastAxis\n\nAn abstract trait that is used to determine how axes are combined when calling broadcast_axis.\n\n\n\n\n\n","category":"type"},{"location":"api/#StaticArrayInterface.LazyAxis","page":"API","title":"StaticArrayInterface.LazyAxis","text":"LazyAxis{N}(parent::AbstractArray)\n\nA lazy representation of axes(parent, N).\n\n\n\n\n\n","category":"type"},{"location":"api/#StaticArrayInterface.StrideIndex","page":"API","title":"StaticArrayInterface.StrideIndex","text":"StrideIndex(x)\n\nSubtype of ArrayIndex that transforms and index using stride layout information derived from x.\n\n\n\n\n\n","category":"type"},{"location":"","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","text":"CurrentModule = StaticArrayInterface","category":"page"},{"location":"#StaticArrayInterface","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"StaticArrayInterface","text":"","category":"section"},{"location":"","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","text":"Designs for new Base array interface primitives, used widely through scientific machine learning (SciML) and other organizations","category":"page"},{"location":"#StaticArrayInterfaceCore","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"StaticArrayInterfaceCore","text":"","category":"section"},{"location":"","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","text":"StaticArrayInterfaceCore is a smaller set of the StaticArrayInterface setup which defines the subset which has no compile time impact. This for example includes simple functions like StaticArrayInterfaceCore.zeromatrix which have simple few dispatch definitions and no dependency on other libraries such as Static.jl. Notably, Static.jl currently has issues with invalidations (https://github.com/SciML/Static.jl/issues/52), and thus anything with static outputs are in the domain of StaticArrayInterface.jl proprer.","category":"page"},{"location":"#Extenion-Packages","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"Extenion Packages","text":"","category":"section"},{"location":"","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","text":"StaticArrayInterface.jl uses extension packages in order to add support for popular libraries to its interface functions. These packages are:","category":"page"},{"location":"","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","text":"StaticArrays.jl\nOffsetArrays.jl","category":"page"},{"location":"#Inheriting-Array-Traits","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"Inheriting Array Traits","text":"","category":"section"},{"location":"","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","text":"Creating an array type with unique behavior in Julia is often accomplished by creating a lazy wrapper around previously defined array types  (e.g. composition by inheritance). This allows the new array type to inherit functionality by redirecting methods to the parent array (e.g., Base.size(x::Wrapper) = size(parent(x))). Generic design limits the need to define an excessive number of methods like this. However, methods used to describe a type's traits often need to be explicitly defined for each trait method. If the the underlying data and access to it are unchanged by it's wrapper the  StaticArrayInterface.is_forwarding_wrapper trait can signal to other trait methods to access its parent data structure. Supporting this for a new type only requires defines these methods:","category":"page"},{"location":"","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","text":"StaticArrayInterface.is_forwarding_wrapper(::Type{<:NewType}) = true\nStaticArrayInterface.parent_type(::Type{<:NewType}) = NewTypeParent\nBase.parent(x::NewType) = x.parent","category":"page"},{"location":"","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","text":"For those authoring new trait methods, this may change the default definition from has_trait(::Type{T}) where {T} = false, to:","category":"page"},{"location":"","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","text":"function has_trait(::Type{T}) where {T}\n    if is_forwarding_wrapper(T)\n        return false\n    else\n        return has_trait(parent_type(T))\n    end\nend","category":"page"},{"location":"","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","text":"Most traits in StaticArrayInterface are a variant on this pattern. If the trait in question may be altered by a wrapper array, this pattern should be altered or may be inappropriate.","category":"page"},{"location":"#Static-Traits","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"Static Traits","text":"","category":"section"},{"location":"","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","text":"The size along one or more dimensions of an array may be known at compile time. StaticArrayInterface.known_size is useful for extracting this information from array types and StaticArrayInterface.static_size is useful for extracting this information from an instance of an array. For example:","category":"page"},{"location":"","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","text":"julia> a = ones(3)';\n\njulia> StaticArrayInterface.static_size(a)\n(static(1), 3)\n\njulia> StaticArrayInterface.known_size(typeof(a))\n(1, nothing)\n","category":"page"},{"location":"","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","text":"This is useful for dispatching on known information about the size of an array:","category":"page"},{"location":"","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","text":"fxn(x) = _fxn(StaticArrayInterface.static_size(x), x)\n_fxn(sz::Tuple{StaticInt{S1},StaticInt{S2}}, x) where {S1,S2} = ...\n_fxn(sz::Tuple{StaticInt{3},StaticInt{3}}, x) = ...\n_fxn(sz::Tuple{Int,StaticInt{S2}}, x) where {S2} = ...\n_fxn(sz::Tuple{StaticInt{S1},Int}, x) where {S1} = ...\n_fxn(sz::Tuple{Int,Int}, x) = ...","category":"page"},{"location":"","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","text":"Methods should avoid forcing conversion to static sizes when dynamic sizes could potentially be returned. Fore example, fxn(x) = _fxn(Static.static(StaticArrayInterface.static_size(x)), x) would result in dynamic dispatch if x is an instance of Matrix. Additionally, StaticArrayInterface.static_size should only be used outside of generated functions to avoid possible world age issues.","category":"page"},{"location":"","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","text":"Generally, StaticArrayInterface.static_size uses the return of known_size to form a static value for those dimensions with known length and only queries dimensions corresponding to nothing. For example, the previous example had a known size of (1, nothing). Therefore, StaticArrayInterface.static_size would have compile time information about the first dimension returned as static(1) and would only look up the size of the second dimension at run time. This means the above example StaticArrayInterface.static_size(a) would lower to code similar to this at compile time: Static.StaticInt(1), Base.arraysize(x, 1). Generic support for StaticArrayInterface.known_size relies on calling known_length for each type returned from axes_types. Therefore, the recommended approach for supporting static sizing in newly defined array types is defining a new axes_types method.","category":"page"},{"location":"","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","text":"Static information related to subtypes of AbstractRange include known_length, known_first, known_step, and known_last.","category":"page"},{"location":"#Dimensions","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"Dimensions","text":"","category":"section"},{"location":"","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","text":"Methods such as size(x, dim) need to map dim to the dimensions of x. Typically, dim is an Int with an invariant mapping to the dimensions of x. Some methods accept : or a tuple of dimensions as an argument. StaticArrayInterface also considers StaticInt a viable dimension argument.","category":"page"},{"location":"","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","text":"StaticArrayInterface.to_dims helps ensure that dim is converted to a viable dimension mapping in a manner that helps with type stability. For example, all Integers passed to to_dims are converted to Int (unless dim is a StaticInt). This is also useful for arrays that uniquely label dimensions, in which case to_dims serves as a safe point of hooking into existing methods with dimension arguments. StaticArrayInterface also defines native Symbol to Int and StaticSymbol to StaticInt mapping  for arrays defining StaticArrayInterface.dimnames.","category":"page"},{"location":"","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","text":"Methods requiring dimension specific arguments should use some variation of the following pattern.","category":"page"},{"location":"","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","text":"f(x, dim) = f(x, StaticArrayInterface.to_dims(x, dim))\nf(x, dim::Int) = ...\nf(x, dim::StaticInt) = ...","category":"page"},{"location":"","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","text":"If x's first dimension is named :dim_1 then calling f(x, :dim_1) would result in f(x, 1). If users knew they always wanted to call f(x, 2) then they could define h(x) = f(x, static(2)), ensuring f passes along that information while compiling.","category":"page"},{"location":"","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","text":"New types defining dimension names can do something similar to:","category":"page"},{"location":"","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","text":"using Static\nusing StaticArrayInterface\n\nstruct StaticDimnames{dnames} end  # where dnames::Tuple{Vararg{Symbol}}\n\nStaticArrayInterface.known_dimnames(::Type{StaticDimnames{dnames}}) where {dnames} = dnames\nStaticArrayInterface.dimnames(::StaticDimnames{dnames}) where {dnames} = static(dnames)\n\nstruct DynamicDimnames{N}\n    dimnames::NTuple{N,Symbol}\nend\nStaticArrayInterface.known_dimnames(::Type{DynamicDimnames{N}}) where {N} = ntuple(_-> nothing, Val(N))\nStaticArrayInterface.dimnames(x::DynamicDimnames) = getfield(x, :dimnames)\n","category":"page"},{"location":"","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","text":"Notice that DynamicDimnames returns nothing instead of a symbol for each dimension. This indicates dimension names are present for DynamicDimnames but that information is nothing at compile time.","category":"page"},{"location":"","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","text":"Dimension names should be appropriately propagated between nested arrays using StaticArrayInterface.to_parent_dims.  This allows types such as SubArray and PermutedDimsArray to work with named dimensions. Similarly, other methods that return information corresponding to dimensions (e.g., ArrayInterfce.size, StaticArrayInterface.static_axes) use to_parent_dims to appropriately propagate parent information.","category":"page"},{"location":"#Axes","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"Axes","text":"","category":"section"},{"location":"","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","text":"Where Julia's currently documented array interface requires defining Base.size,  StaticArrayInterface instead requires defining StaticArrayInterface.static_axes and StaticArrayInterface.axes_types. StaticArrayInterface.axes_types(::Type{T}) facilitates propagation of a number of traits known at compile time (e.g., known_size, known_offsets)  and StaticArrayInterface.static_axes(::AbstractArray) replaces Base.OneTo with StaticArrayInterface.OptionallyStaticUnitRange in situations where static  information would otherwise be lost. StaticArrayInterface.static_axes(::AbstractArray, dim) utilizes to_dims, as described elsewhere.","category":"page"},{"location":"#Simple-Wrappers","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"Simple Wrappers","text":"","category":"section"},{"location":"","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","text":"Let's say we have a new array type doesn't affect axes then this is as simple as:","category":"page"},{"location":"","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","text":"Base.axes(x::SimpleWrapper) = StaticArrayInterface.static_axes(parent(x))\nBase.axes(x::SimpleWrapper, dim) = StaticArrayInterface.static_axes(parent(x), dim)\nStaticArrayInterface.axes_types(::Type{T}) where {T<:SimpleWrapper} = axes_types(parent_type(T))","category":"page"},{"location":"","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","text":"To reiterate, StaticArrayInterface.static_axes improves on Base.axes for few Base array types but is otherwise identical. Therefore, the first method simply ensures you don't have to define multiple parametric methods for your new type to preserve  statically sized nested axes (e.g., SimpleWrapper{T,N,<:Transpose{T,<:AbstractVector}}). This is otherwise identical to standard inheritance by composition.","category":"page"},{"location":"#When-to-Discard-Axis-Information","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"When to Discard Axis Information","text":"","category":"section"},{"location":"","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","text":"Occasionally the parent array's axis information can't be preserved. For example, we can't map axis information from the parent array of Base.ReshapedArray. In this case we can simply build axes from the new size information.","category":"page"},{"location":"","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","text":"StaticArrayInterface.axes_types(T::Type{<:ReshapedArray}) = NTuple{ndims(T),OneTo{Int}}\nStaticArrayInterface.static_axes(A::ReshapedArray) = map(OneTo, size(A))","category":"page"},{"location":"#New-Axis-Types","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"New Axis Types","text":"","category":"section"},{"location":"","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","text":"OffsetArray changes the first index for each axis. It produces axes of type IdOffsetRange, which contains the value of the relative offset and the parent axis.","category":"page"},{"location":"","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","text":"using StaticArrayInterface: axes_types, parent_type, to_dims\n# Note that generating a `Tuple` type piecewise like may be type unstable and should be\n# tested using `Test.@inferred`. It's often necessary to use generated function\n# (`@generated`) or methods defined in Static.jl.\n@generated function StaticArrayInterface.axes_types(::Type{A}) where {A<:OffsetArray}\n    out = Expr(:curly, :Tuple)\n    P = parent_type(A)\n    for dim in 1:ndims(A)\n        # offset relative to parent array\n        O = relative_known_offsets(A, dim)\n        if O === nothing  # offset is not known at compile time and is an `Int`\n            push!(out.args, :(IdOffsetRange{Int, axes_types($P, $(static(dim)))}))\n        else # offset is known, therefore it is a `StaticInt`\n            push!(out.args, :(IdOffsetRange{StaticInt{$O}, axes_types($P, $(static(dim))}))\n        end\n    end\nend\nfunction Base.axes(A::OffsetArray)\n    map(IdOffsetRange, StaticArrayInterface.static_axes(parent(A)), relative_offsets(A))\nend\nfunction Base.axes(A::OffsetArray, dim)\n    d = to_dims(A, dim)\n    IdOffsetRange(StaticArrayInterface.static_axes(parent(A), d), relative_offsets(A, d))\nend","category":"page"},{"location":"","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","text":"Defining these two methods ensures that other array types that wrap OffsetArray and appropriately define these methods  propagate offsets independent of any dependency on OffsetArray. It is entirely optional to define StaticArrayInterface.static_size for OffsetArray because the size can be  derived from the axes. However, in this particularly case we should also define  StaticArrayInterface.static_size(A::OffsetArray)  = StaticArrayInterface.static_size(parent(A)) because the relative offsets   attached to OffsetArray do not change the size but may hide static sizes if using a relative offset that is defined with an Int.","category":"page"},{"location":"#Processing-Indices-(static_to_indices)","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"Processing Indices (static_to_indices)","text":"","category":"section"},{"location":"","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","text":"For most users, the only reason you should use StaticArrayInterface.static_to_indices over Base.to_indices is that it's  faster and perhaps some of the more detailed benefits described in the to_indices doc string. For those interested in how this is accomplished, the following steps (beginning with the to_indices(A::AbstractArray, I::Tuple))  are used to accomplish this:","category":"page"},{"location":"","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","text":"The number of dimensions that each indexing argument in I corresponds to is determined using using the ndims_index and is_splat_index traits.\nA non-allocating reference to each axis of A is created (lazy_axes(A) -> axs). These are aligned to each the index arguments using information from the first step. For example, if an index argument maps to a single dimension then it is paired with axs[dim]. In the case of multiple dimensions it is paired with CartesianIndices(axs[dim_1], ... axs[dim_n]). These pairs are further processed using to_index(axis, I[n]).\nTuples returned from to_index are flattened out so that there are no nested tuples returned from to_indices.","category":"page"},{"location":"","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","text":"Entry points:","category":"page"},{"location":"","page":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","title":"StaticArrayInterface.jl: Static Compile-Time Enforced Array Interface Functionality","text":"static_to_indices(::ArrayType, indices) : dispatch on unique array type ArrayType\nto_index(axis, ::IndexType) : dispatch on a unique indexing type, IndexType. StaticArrayInterface.ndims_index(::Type{IndexType}) should also be defined in this case.\nto_index(S::IndexStyle, axis, index) : The index style S that corresponds to axis. This is ","category":"page"}]
}
